// Comprehensive test for support system infrastructure
const mongoose = require('mongoose');

const MONGODB_URI = 'mongodb+srv://kanishkumar:kanish1234@cluster0.2zf36.mongodb.net/sourcingscreen';

// Define schemas directly for testing (since we can't import TS files)
const TicketCategory = {
  TECHNICAL_ISSUE: "Technical Issue",
  ACCOUNT_ISSUE: "Account Issue",
  FEATURE_REQUEST: "Feature Request",
  GENERAL_INQUIRY: "General Inquiry",
  BUG_REPORT: "Bug Report",
};

const TicketPriority = {
  LOW: "Low",
  MEDIUM: "Medium",
  HIGH: "High",
  CRITICAL: "Critical",
};

const TicketStatus = {
  OPEN: "Open",
  IN_PROGRESS: "In Progress",
  RESOLVED: "Resolved",
  CLOSED: "Closed",
};

// Ticket response schema
const TicketResponseSchema = new mongoose.Schema({
  message: {
    type: String,
    required: true,
    trim: true,
    maxlength: 5000,
  },
  respondedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  isInternal: {
    type: Boolean,
    default: false,
  },
}, {
  timestamps: { createdAt: true, updatedAt: false },
});

// Support ticket schema
const SupportTicketSchema = new mongoose.Schema({
  ticketNumber: {
    type: String,
    required: false, // Will be generated by pre-save middleware
    unique: true,
    trim: true,
  },
  subject: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200,
  },
  message: {
    type: String,
    required: true,
    trim: true,
    maxlength: 10000,
  },
  category: {
    type: String,
    enum: Object.values(TicketCategory),
    required: true,
    default: TicketCategory.GENERAL_INQUIRY,
  },
  priority: {
    type: String,
    enum: Object.values(TicketPriority),
    required: true,
    default: TicketPriority.MEDIUM,
  },
  status: {
    type: String,
    enum: Object.values(TicketStatus),
    required: true,
    default: TicketStatus.OPEN,
  },
  submittedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
  },
  responses: [TicketResponseSchema],
  attachments: [{
    type: String,
    trim: true,
  }],
  resolvedAt: {
    type: Date,
  },
  closedAt: {
    type: Date,
  },
}, {
  timestamps: true,
});

// Add indexes
SupportTicketSchema.index({ submittedBy: 1, createdAt: -1 });
SupportTicketSchema.index({ status: 1, priority: -1, createdAt: -1 });
SupportTicketSchema.index({ assignedTo: 1, status: 1 });
SupportTicketSchema.index({ ticketNumber: 1 }, { unique: true });
SupportTicketSchema.index({ category: 1, createdAt: -1 });
SupportTicketSchema.index({
  subject: "text",
  message: "text",
  "responses.message": "text",
});

// Pre-save middleware for ticket number generation
SupportTicketSchema.pre("save", async function (next) {
  if (this.isNew && !this.ticketNumber) {
    try {
      const year = new Date().getFullYear();
      // Use this.constructor to avoid circular reference issues
      const count = await this.constructor.countDocuments({
        createdAt: {
          $gte: new Date(year, 0, 1),
          $lt: new Date(year + 1, 0, 1),
        },
      });
      this.ticketNumber = `ST-${year}-${String(count + 1).padStart(3, "0")}`;
    } catch (error) {
      // Fallback to timestamp-based ticket number if count fails
      const timestamp = Date.now().toString().slice(-6);
      const year = new Date().getFullYear();
      this.ticketNumber = `ST-${year}-${timestamp}`;
    }
  }
  next();
});

// Pre-save middleware for status dates
SupportTicketSchema.pre("save", function (next) {
  if (this.isModified("status")) {
    if (this.status === TicketStatus.RESOLVED && !this.resolvedAt) {
      this.resolvedAt = new Date();
    }
    if (this.status === TicketStatus.CLOSED && !this.closedAt) {
      this.closedAt = new Date();
    }
  }
  next();
});

// Settings schema
const SettingsSchema = new mongoose.Schema({
  key: {
    type: String,
    required: true,
    unique: true,
    trim: true,
  },
  value: {
    type: mongoose.Schema.Types.Mixed,
    required: true,
  },
  description: {
    type: String,
    trim: true,
  },
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
}, {
  timestamps: true,
});

SettingsSchema.index({ key: 1 });

async function verifyInfrastructure() {
  console.log('üß™ VERIFYING SUPPORT SYSTEM INFRASTRUCTURE');
  console.log('==========================================\n');

  try {
    // Connect to MongoDB
    console.log('1Ô∏è‚É£ Connecting to MongoDB...');
    await mongoose.connect(MONGODB_URI);
    console.log('‚úÖ Connected to MongoDB\n');

    // Create models
    const SupportTicket = mongoose.model('SupportTicket', SupportTicketSchema);
    const Settings = mongoose.model('Settings', SettingsSchema);

    console.log('2Ô∏è‚É£ Testing SupportTicket model...');

    // Test ticket creation with auto-generated ticket number
    const testUserId = new mongoose.Types.ObjectId();
    const testTicket = new SupportTicket({
      subject: 'Test Support Ticket',
      message: 'This is a test message for the support ticket system.',
      category: TicketCategory.TECHNICAL_ISSUE,
      priority: TicketPriority.MEDIUM,
      submittedBy: testUserId,
    });

    await testTicket.save();
    console.log(`‚úÖ Created test ticket with number: ${testTicket.ticketNumber}`);
    console.log(`‚úÖ Ticket ID: ${testTicket._id}`);

    // Test ticket response
    testTicket.responses.push({
      message: 'This is a test response',
      respondedBy: testUserId,
      isInternal: false,
    });
    await testTicket.save();
    console.log('‚úÖ Added response to ticket');

    // Test status update with automatic date setting
    testTicket.status = TicketStatus.RESOLVED;
    await testTicket.save();
    console.log(`‚úÖ Updated ticket status to resolved at: ${testTicket.resolvedAt}`);

    console.log('\n3Ô∏è‚É£ Testing Settings model...');

    // Test settings creation
    const testSetting = new Settings({
      key: 'support_email',
      value: 'test@example.com',
      description: 'Test support email setting',
      updatedBy: testUserId,
    });

    await testSetting.save();
    console.log('‚úÖ Created test setting');

    // Test settings retrieval
    const retrievedSetting = await Settings.findOne({ key: 'support_email' });
    console.log(`‚úÖ Retrieved setting value: ${retrievedSetting.value}`);

    console.log('\n4Ô∏è‚É£ Testing database indexes...');

    // Check if indexes were created
    const ticketIndexes = await SupportTicket.collection.getIndexes();
    console.log(`‚úÖ SupportTicket has ${Object.keys(ticketIndexes).length} indexes`);

    const settingsIndexes = await Settings.collection.getIndexes();
    console.log(`‚úÖ Settings has ${Object.keys(settingsIndexes).length} indexes`);

    console.log('\n5Ô∏è‚É£ Testing search functionality...');

    // Test text search
    const searchResults = await SupportTicket.find({
      $text: { $search: 'test' }
    });
    console.log(`‚úÖ Text search returned ${searchResults.length} results`);

    console.log('\n6Ô∏è‚É£ Testing utility functions...');

    // Test ticket number generation
    function generateTicketNumber(count) {
      const year = new Date().getFullYear();
      return `ST-${year}-${String(count + 1).padStart(3, '0')}`;
    }

    const nextTicketNumber = generateTicketNumber(1);
    console.log(`‚úÖ Next ticket number would be: ${nextTicketNumber}`);

    // Test validation
    function validateTicketData(data) {
      const errors = [];

      if (!data.subject || data.subject.trim().length === 0) {
        errors.push("Subject is required");
      }

      if (!data.message || data.message.trim().length === 0) {
        errors.push("Message is required");
      }

      return { isValid: errors.length === 0, errors };
    }

    const validationResult = validateTicketData({
      subject: 'Test Subject',
      message: 'Test Message'
    });
    console.log(`‚úÖ Validation working: ${validationResult.isValid}`);

    console.log('\n7Ô∏è‚É£ Cleaning up test data...');

    // Clean up test data
    await SupportTicket.deleteOne({ _id: testTicket._id });
    await Settings.deleteOne({ _id: testSetting._id });
    console.log('‚úÖ Test data cleaned up');

    console.log('\nüéâ INFRASTRUCTURE VERIFICATION COMPLETE');
    console.log('======================================');
    console.log('‚úÖ SupportTicket model working correctly');
    console.log('‚úÖ Settings model working correctly');
    console.log('‚úÖ Database indexes created successfully');
    console.log('‚úÖ Ticket number auto-generation working');
    console.log('‚úÖ Status date auto-update working');
    console.log('‚úÖ Text search functionality working');
    console.log('‚úÖ Validation utilities working');
    console.log('‚úÖ All database operations successful');
    console.log('\nüöÄ Ready to implement API endpoints!');

  } catch (error) {
    console.error('‚ùå Infrastructure verification failed:', error);

    if (error.code === 11000) {
      console.log('‚ÑπÔ∏è This might be a duplicate key error - cleaning up...');
      try {
        await mongoose.connection.db.collection('supporttickets').deleteMany({ subject: 'Test Support Ticket' });
        await mongoose.connection.db.collection('settings').deleteMany({ key: 'support_email' });
        console.log('‚úÖ Cleaned up any duplicate test data');
      } catch (cleanupError) {
        console.log('‚ö†Ô∏è Could not clean up test data:', cleanupError.message);
      }
    }
  } finally {
    await mongoose.disconnect();
    console.log('\nüîå Database disconnected');
  }
}

verifyInfrastructure();