import mongoose, { Document, Schema } from "mongoose";

// Enums for ticket properties
export enum TicketCategory {
  TECHNICAL_ISSUE = "Technical Issue",
  ACCOUNT_ISSUE = "Account Issue",
  FEATURE_REQUEST = "Feature Request",
  GENERAL_INQUIRY = "General Inquiry",
  BUG_REPORT = "Bug Report",
}

export enum TicketPriority {
  LOW = "Low",
  MEDIUM = "Medium",
  HIGH = "High",
  CRITICAL = "Critical",
}

export enum TicketStatus {
  OPEN = "Open",
  IN_PROGRESS = "In Progress",
  RESOLVED = "Resolved",
  CLOSED = "Closed",
}

// Interface for ticket responses
export interface ITicketResponse {
  _id: mongoose.Types.ObjectId;
  message: string;
  respondedBy: mongoose.Types.ObjectId;
  isInternal: boolean;
  createdAt: Date;
}

// Main support ticket interface
export interface ISupportTicket extends Document {
  ticketNumber: string;
  subject: string;
  message: string;
  category: TicketCategory;
  priority: TicketPriority;
  status: TicketStatus;
  submittedBy: mongoose.Types.ObjectId;
  assignedTo?: mongoose.Types.ObjectId;
  responses: ITicketResponse[];
  attachments?: string[];
  createdAt: Date;
  updatedAt: Date;
  resolvedAt?: Date;
  closedAt?: Date;
}

// Ticket response schema
const TicketResponseSchema = new Schema<ITicketResponse>(
  {
    message: {
      type: String,
      required: true,
      trim: true,
      maxlength: 5000,
    },
    respondedBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    isInternal: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: { createdAt: true, updatedAt: false },
  }
);

// Main support ticket schema
const SupportTicketSchema = new Schema<ISupportTicket>(
  {
    ticketNumber: {
      type: String,
      required: false, // Will be generated by pre-save middleware
      unique: true,
      trim: true,
    },
    subject: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },
    message: {
      type: String,
      required: true,
      trim: true,
      maxlength: 10000,
    },
    category: {
      type: String,
      enum: Object.values(TicketCategory),
      required: true,
      default: TicketCategory.GENERAL_INQUIRY,
    },
    priority: {
      type: String,
      enum: Object.values(TicketPriority),
      required: true,
      default: TicketPriority.MEDIUM,
    },
    status: {
      type: String,
      enum: Object.values(TicketStatus),
      required: true,
      default: TicketStatus.OPEN,
    },
    submittedBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    assignedTo: {
      type: Schema.Types.ObjectId,
      ref: "User",
    },
    responses: [TicketResponseSchema],
    attachments: [
      {
        type: String,
        trim: true,
      },
    ],
    resolvedAt: {
      type: Date,
    },
    closedAt: {
      type: Date,
    },
  },
  {
    timestamps: true,
  }
);

// Indexes for optimal query performance
SupportTicketSchema.index({ submittedBy: 1, createdAt: -1 });
SupportTicketSchema.index({ status: 1, priority: -1, createdAt: -1 });
SupportTicketSchema.index({ assignedTo: 1, status: 1 });
// Unique index is already handled by the schema field definition
SupportTicketSchema.index({ category: 1, createdAt: -1 });

// Text index for search functionality
SupportTicketSchema.index({
  subject: "text",
  message: "text",
  "responses.message": "text",
});

// Pre-save middleware to generate ticket number
SupportTicketSchema.pre("save", async function (next) {
  if (this.isNew && !this.ticketNumber) {
    try {
      const year = new Date().getFullYear();
      // Use this.constructor to avoid circular reference issues
      const count = await (this.constructor as any).countDocuments({
        createdAt: {
          $gte: new Date(year, 0, 1),
          $lt: new Date(year + 1, 0, 1),
        },
      });
      this.ticketNumber = `ST-${year}-${String(count + 1).padStart(3, "0")}`;
    } catch (error) {
      // Fallback to timestamp-based ticket number if count fails
      const timestamp = Date.now().toString().slice(-6);
      const year = new Date().getFullYear();
      this.ticketNumber = `ST-${year}-${timestamp}`;
    }
  }
  next();
});

// Pre-save middleware to set resolved/closed dates
SupportTicketSchema.pre("save", function (next) {
  if (this.isModified("status")) {
    if (this.status === TicketStatus.RESOLVED && !this.resolvedAt) {
      this.resolvedAt = new Date();
    }
    if (this.status === TicketStatus.CLOSED && !this.closedAt) {
      this.closedAt = new Date();
    }
  }
  next();
});

export default mongoose.models.SupportTicket ||
  mongoose.model<ISupportTicket>("SupportTicket", SupportTicketSchema);
